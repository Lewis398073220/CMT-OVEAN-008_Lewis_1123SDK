/***************************************************************************
 *
 * Copyright 2015-2021 BES.
 * All rights reserved. All unpublished rights reserved.
 *
 * No part of this work may be used or reproduced in any form or by any
 * means, or stored in a database or retrieval system, without prior written
 * permission of BES.
 *
 * Use of this work is governed by a license granted by BES.
 * This work contains confidential and proprietary information of
 * BES. which is protected by copyright, trade secret,
 * trademark and other intellectual property rights.
 *
 ****************************************************************************/
#include "hal_ipc_notify_api.h"
#include "hal_ipc_notify.h"
#include "hal_trace.h"
#include "string.h"


void hal_ipc_notify_internal_rx_irq_handler(const struct HAL_IPC_NOTIFY_CFG_T *cfg)
{
    uint32_t id;
    struct HAL_IPC_NOTIFY_CH_CFG_T *chan_cfg;

    chan_cfg = cfg->chan_cfg;

    for (id = 0; id < cfg->chan_num; id++) {
        if (!cfg->chan_cfg[id].chan_opened){
            continue;
        }
        if (cfg->irq_active(id, HAL_IPC_NOTIFY_IRQ_SEND_IND)) {
            cfg->rx_done(id);
            if (chan_cfg[id].rx_irq_handler) {
                 chan_cfg[id].rx_irq_handler(cfg->core, id);
            }
        }
    }
}

static void hal_rmt_ipc_tx_irq_handler_by_id(const struct HAL_IPC_NOTIFY_CFG_T *cfg, uint32_t id)
{
    struct HAL_IPC_NOTIFY_CH_CFG_T *chan_cfg;

    chan_cfg = cfg->chan_cfg;

    if (cfg->irq_active(id, HAL_IPC_NOTIFY_IRQ_RECV_DONE)) {
        cfg->local_tx_irq_clear(id);
        if (chan_cfg[id].tx_irq_handler) {
             chan_cfg[id].tx_irq_handler(cfg->core, id);
        }
    }
}

void hal_ipc_notify_internal_tx_irq_handler(const struct HAL_IPC_NOTIFY_CFG_T *cfg)
{
    uint32_t id;

    for (id = 0; id < cfg->chan_num; id++) {
        if (!cfg->chan_cfg[id].chan_opened){
            continue;
        }
        hal_rmt_ipc_tx_irq_handler_by_id(cfg, id);
    }
}

int hal_ipc_notify_internal_open(const struct HAL_IPC_NOTIFY_CFG_T *cfg, uint32_t id, HAL_IPC_NOTIFY_RX_IRQ_HANDLER rxhandler, HAL_IPC_NOTIFY_RX_IRQ_HANDLER txhandler)
{
    if (id >= cfg->chan_num) {
        return 1;
    }

    if (cfg->chan_cfg[id].chan_opened) {
        return 3;
    } else {
        // Stop IRQs by default
        NVIC_DisableIRQ(cfg->rx_irq_id[id]);
        NVIC_DisableIRQ(cfg->tx_irq_id[id]);

        NVIC_SetVector(cfg->rx_irq_id[id], (uint32_t)cfg->rx_irq_entry);
        NVIC_SetPriority(cfg->rx_irq_id[id], IRQ_PRIORITY_NORMAL);

        NVIC_SetVector(cfg->tx_irq_id[id], (uint32_t)cfg->tx_irq_entry);
        NVIC_SetPriority(cfg->tx_irq_id[id], IRQ_PRIORITY_NORMAL);

        cfg->irq_init(id);

        __DSB();
        memset(&cfg->chan_cfg[id], 0, sizeof(cfg->chan_cfg[id]));

        // Enable TX IRQ
        NVIC_ClearPendingIRQ(cfg->tx_irq_id[id]);
        NVIC_EnableIRQ(cfg->tx_irq_id[id]);
    }

    cfg->chan_cfg[id].chan_opened = true;

    cfg->chan_cfg[id].rx_irq_handler = rxhandler;
    cfg->chan_cfg[id].tx_irq_handler = txhandler;

    return 0;
}

int hal_ipc_notify_internal_close(const struct HAL_IPC_NOTIFY_CFG_T *cfg, uint32_t id)
{
    if (id >= cfg->chan_num) {
        return 1;
    }

    // Stop IRQs by default
    NVIC_DisableIRQ(cfg->rx_irq_id[id]);
    NVIC_DisableIRQ(cfg->tx_irq_id[id]);

    // Clear IRQs generated by local
    cfg->irq_init(id);

    memset(&cfg->chan_cfg[id], 0, sizeof(cfg->chan_cfg[id]));

    return 0;
}


int hal_ipc_notify_internal_start_recv(const struct HAL_IPC_NOTIFY_CFG_T *cfg, uint32_t id)
{
    if (id >= cfg->chan_num) {
        return 1;
    }
    
    if (!cfg->chan_cfg[id].chan_opened){
        return 1;
    }
    
    NVIC_ClearPendingIRQ(cfg->rx_irq_id[id]);
    NVIC_EnableIRQ(cfg->rx_irq_id[id]);

    return 0;
}

int hal_ipc_notify_internal_stop_recv(const struct HAL_IPC_NOTIFY_CFG_T *cfg, uint32_t id)
{
    if (id >= cfg->chan_num) {
        return 1;
    }

    NVIC_DisableIRQ(cfg->rx_irq_id[id]);

    return 0;
}

int hal_ipc_notify_internal_peer_irq_set(const struct HAL_IPC_NOTIFY_CFG_T *cfg, uint32_t id)
{
    if (!cfg->chan_cfg[id].chan_opened){
        return 1;
    }

    __DSB();
    cfg->peer_tx_irq_set(id);

    return 0;
}

int hal_ipc_notify_internal_opened(const struct HAL_IPC_NOTIFY_CFG_T *cfg, uint32_t id)
{
    return !!cfg->chan_cfg[id].chan_opened;
}


