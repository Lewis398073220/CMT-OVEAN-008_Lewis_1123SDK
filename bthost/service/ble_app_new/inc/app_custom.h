/***************************************************************************
 *
 * Copyright 2015-2023 BES.
 * All rights reserved. All unpublished rights reserved.
 *
 * No part of this work may be used or reproduced in any form or by any
 * means, or stored in a database or retrieval system, without prior written
 * permission of BES.
 *
 * Use of this work is governed by a license granted by BES.
 * This work contains confidential and proprietary information of
 * BES. which is protected by copyright, trade secret,
 * trademark and other intellectual property rights.
 *
 ****************************************************************************/
#ifndef __APP_CUSTOMIF_H__
#define __APP_CUSTOMIF_H__
#include "ble_core_common.h"
#include "hal_timer.h"
#ifdef __cplusplus
extern "C" {
#endif

typedef void (*ble_adv_data_report_cb_t)(ble_bdaddr_t *bleAddr, int8_t rssi, uint8_t evt_type, uint8_t *adv_buf, uint8_t len);
typedef void (*ble_link_event_report_cb_t)(int32_t connId, uint8_t* bdAddr, ble_evnet_type_e event, uint8_t err_code);

void app_ble_customif_init(void);
void app_ble_customif_adv_report_callback_register(ble_adv_data_report_cb_t cb);
void app_ble_customif_adv_report_callback_deregister(void);
void app_ble_customif_link_event_callback_register(ble_link_event_report_cb_t cb);
void app_ble_customif_link_event_callback_deregister(void);

typedef struct
{
    BLE_ADV_ACTIVITY_USER_E adv_actv_user;
    bool user_enable;
    BLE_ADV_USER_E adv_user;
    bool withFlags;
    uint8_t filter_pol;
    int8_t tx_power_dbm;
    BLE_ADV_TYPE_E advType;
    ADV_MODE_E advMode;
    uint32_t advUserInterval;
    uint32_t PeriodicIntervalMin;
    uint32_t PeriodicIntervalMax;
    gap_dt_buf_t adv_data;
    gap_dt_buf_t scan_rsp_data;
    uint8_t localAddrType;
    bt_bdaddr_t localAddr;
    ble_bdaddr_t peerAddr;
} CUSTOMER_ADV_PARAM_T;

CUSTOMER_ADV_PARAM_T * app_ble_custom_adv_param_ptr(BLE_ADV_ACTIVITY_USER_E actv_user);

void app_ble_custom_init(void);
void app_ble_custom_adv_start(BLE_ADV_ACTIVITY_USER_E actv_user);
void app_ble_custom_adv_stop(BLE_ADV_ACTIVITY_USER_E actv_user);
void app_ble_start_three_adv_test(void);
void app_ble_start_connectable_adv_by_custom_adv(uint16_t advInterval);
void app_ble_refresh_adv_state_by_custom_adv(uint16_t advInterval);

/**
 * app_ble_custom_adv_write_data
 *
 *    actv_user: The user of the adv activity
 *    is_custom_adv_flags: If this flag was set, custom can set adv flag by himself
 *    type : adv addr type
 *               BLE_ADV_PUBLIC_STATIC   Don't care about local_addr, just use identity ble addr.
 *               BLE_ADV_PRIVATE_STATIC  Just use local_addr.
 *               BLE_ADV_RPA    local_addr shall be set to ff:ff:ff:ff:ff:ff. If the resolving list contains
 *                              no matching entry, use rpa generated by host;otherwise use rpa generated by control.
 *               !!!If wants to use rpa, the premise is to open the macro BLE_ADV_RPA_ENABLED
 *    local_addr: The local address of this adv. ff:ff:ff:ff:ff:ff when rpa.
 *    peer_addr: If adv_type is direct adv, this param is the address of peer ble
 *    adv_interval: Adv interval
 *    adv_type: Adv type
 *    adv_mode: Adv mode
 *    tx_power_dbm: Adv tx power in dbm, range: -3~16
 *    adv_data: Adv data
 *    adv_data_size: Adv data size
 *    scan_rsp_data: Scan response data
 *    scan_rsp_data_size: Scan response data size
 */
void app_ble_custom_adv_write_data(BLE_ADV_ACTIVITY_USER_E actv_user,
                    bool is_custom_adv_flags,
                    BLE_ADV_ADDR_TYPE_E type,
                    uint8_t *local_addr,
                    ble_bdaddr_t *peer_addr,
                    uint32_t adv_interval,
                    BLE_ADV_TYPE_E adv_type,
                    ADV_MODE_E adv_mode,
                    int8_t tx_power_dbm,
                    uint8_t *adv_data, uint8_t adv_data_size,
                    uint8_t *scan_rsp_data, uint8_t scan_rsp_data_size);

typedef enum
{
    /* 0 */ OP_RESPONSE_TO_CMD = 0,    /**< the payload is: OP_RESPONSE_TO_CMD + paramLen + BLE_CUSTOM_CMD_RSP_T */
    /* 1 */ OP_START_RAW_DATA_XFER,    /**< raw data means no BLE_CUSTOM_CMD_PAYLOAD_T.cmdCode but just the data
                                starting raw data xfer is done via:
                                    1. send OP_START_RAW_DATA_XFER to target peer device 
                                    2. get OP_RESPONSE_TO_CMD from the target device
                                    3. send raw data
                            */
    /* 2 */ OP_STOP_RAW_DATA_XFER,    /**< raw data means no BLE_CUSTOM_CMD_PAYLOAD_T.cmdCode but just the data
                                stopping raw data xfer is done via:
                                    1. send OP_STOP_RAW_DATA_XFER to target peer device 
                                    2. get OP_RESPONSE_TO_CMD from the target device
                                    3. stop sending raw data
                            */
    /* 3 */ OP_TEST_NO_RESPONSE_PRINT,

    /* 4 */ OP_TEST_WITH_RESPONSE_PRINT,

    /* 5 */ OP_ENTER_OTA_MODE,
    // TO ADD: new custom command code

    /* 6 */ OP_SW_IIR_EQ,        

    /* 7 */ OP_GET_BT_ADDRESS,

    /* 8 */ OP_DONGLE_TOTA_RECEIVE_DATA,

    /* 9 */ OP_HEADSET_TOTA_RECEIVE_DATA,

    /* 10 */ OP_SEND_HID_COMMAND_TO_DONGLE,

    /* 11 */ OP_COMMAND_COUNT,
} BLE_CUSTOM_CMD_CODE_E;

#define GET_CURRENT_TICKS() hal_sys_timer_get()

#define GET_CURRENT_MS() TICKS_TO_MS(GET_CURRENT_TICKS())

extern uint32_t __custom_handler_table_start[];
extern uint32_t __custom_handler_table_end[];

#define CUSTOM_COMMAND_TO_ADD(cmdCode, cmdHandler, isNeedResponse, timeoutWaitingRspInMs, cmdRspHandler) \
    static const BLE_CUSTOM_CMD_INSTANCE_T cmdCode##_entry __attribute__((used, section(".custom_handler_table"))) = \
        {(cmdCode), (cmdHandler), (isNeedResponse), (timeoutWaitingRspInMs), (cmdRspHandler)};

#define CUSTOM_COMMAND_PTR_FROM_ENTRY_INDEX(index) \
    ((BLE_CUSTOM_CMD_INSTANCE_T *)((uint32_t)__custom_handler_table_start + (index)*sizeof(BLE_CUSTOM_CMD_INSTANCE_T)))

#define BLE_CUSTOM_COMMAND_TO_ADD(cmdCode, cmdHandler, isNeedResponse, timeoutWaitingRspInMs, cmdRspHandler) \
            CUSTOM_COMMAND_TO_ADD(cmdCode, cmdHandler, isNeedResponse, timeoutWaitingRspInMs, cmdRspHandler)

#define BLE_CUSTOM_COMMAND_PTR_FROM_ENTRY_INDEX(index) \
            CUSTOM_COMMAND_PTR_FROM_ENTRY_INDEX(index)

#define INVALID_CUSTOM_ENTRY_INDEX 0xFFFF

typedef enum
{
    NO_ERROR = 0,
    INVALID_CMD_CODE,
    PARAMETER_LENGTH_OUT_OF_RANGE,
    PARAMETER_LENGTH_TOO_SHORT,
    HANDLING_FAILED,
    TIMEOUT_WAITING_RESPONSE,
    // TO ADD: new return status
} BLE_CUSTOM_CMD_RET_STATUS_E;

typedef enum
{
    TRANSMISSION_VIA_NOTIFICATION = 0,
    TRANSMISSION_VIA_INDICATION,
    TRANSMISSION_VIA_WRITE_CMD,
    TRANSMISSION_VIA_WRITE_REQ,
} BLE_CUSTOM_CMD_TRANSMISSION_PATH_E;

typedef void (*BLE_CustomCmdHandler_t)(uint32_t cmdCode, uint8_t* ptrParam, uint32_t paramLen);

typedef void (*BLE_CustomCmd_Response_Handler_t)(BLE_CUSTOM_CMD_RET_STATUS_E retStatus, uint8_t* ptrParam, uint32_t paramLen);

typedef void (*BLE_RawDataReceived_Handler_t)(uint8_t* ptrData, uint32_t dataLen);

typedef struct
{
    uint16_t cmdCode;
    BLE_CustomCmdHandler_t cmdHandler; /**< command handler function */
    uint8_t isNeedResponse; /**< true if needs the response from the peer device */
    uint16_t timeoutWaitingRspInMs; /**< time-out of waiting for response in milli-seconds */
    BLE_CustomCmd_Response_Handler_t cmdRspHandler; /**< command response handler function */
} BLE_CUSTOM_CMD_INSTANCE_T;

#define BLE_CUSTOM_CMD_MAXIMUM_PAYLOAD_SIZE 20 // assure that one BLE packet can include all the data 

typedef struct
{
    uint16_t cmdCode; /**< command code, from BLE_CUSTOM_CMD_CODE_E */
    uint16_t paramLen; /**< length of the following parameter */
    uint8_t param[BLE_CUSTOM_CMD_MAXIMUM_PAYLOAD_SIZE - 2*sizeof(uint16_t)];
} BLE_CUSTOM_CMD_PAYLOAD_T;

typedef struct
{
    uint16_t cmdCodeToRsp; /**< tell which command code to response */
    uint16_t cmdRetStatus; /**< handling result of the command, from BLE_CUSTOM_CMD_RET_STATUS_E */
    uint16_t rspDataLen; /**< length of the response data */
    uint8_t rspData[BLE_CUSTOM_CMD_MAXIMUM_PAYLOAD_SIZE - 5*sizeof(uint16_t)];
} BLE_CUSTOM_CMD_RSP_T;

void BLE_get_response_handler(uint32_t funcCode, uint8_t* ptrParam, uint32_t paramLen);
void BLE_raw_data_xfer_control_handler(uint32_t funcCode, uint8_t* ptrParam, uint32_t paramLen);
void BLE_control_raw_data_xfer(bool isStartXfer);
void BLE_set_raw_data_xfer_received_callback(BLE_RawDataReceived_Handler_t callback);
void BLE_start_raw_data_xfer_control_rsp_handler(BLE_CUSTOM_CMD_RET_STATUS_E retStatus, uint8_t* ptrParam, uint32_t paramLen);
void BLE_stop_raw_data_xfer_control_rsp_handler(BLE_CUSTOM_CMD_RET_STATUS_E retStatus, uint8_t* ptrParam, uint32_t paramLen);
uint8_t *BLE_custom_command_raw_data_buffer_pointer(void);
uint16_t BLE_custom_command_received_raw_data_size(void);
BLE_CUSTOM_CMD_RET_STATUS_E BLE_send_response_to_command(uint32_t responsedCmdCode, BLE_CUSTOM_CMD_RET_STATUS_E returnStatus, 
    uint8_t* rspData, uint32_t rspDataLen, BLE_CUSTOM_CMD_TRANSMISSION_PATH_E path);
BLE_CUSTOM_CMD_RET_STATUS_E BLE_send_custom_command(uint32_t cmdCode, uint8_t* ptrParam, uint32_t paramLen, BLE_CUSTOM_CMD_TRANSMISSION_PATH_E path);
BLE_CUSTOM_CMD_RET_STATUS_E BLE_custom_command_receive_data(uint8_t* ptrData, uint32_t dataLength);
void bes_custom_command_init(void);
BLE_CUSTOM_CMD_INSTANCE_T *BLE_custom_command_get_entry_pointer_from_cmd_code(uint16_t cmdCode);
uint16_t BLE_custom_command_get_entry_index_from_cmd_code(uint16_t cmdCode);

#ifdef __cplusplus
}
#endif
#endif /* __APP_CUSTOMIF_H__ */
