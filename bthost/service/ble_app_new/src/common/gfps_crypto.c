#ifdef GFPS_ENABLED
#include <string.h>
#include "encrypt/aes.h" // utils/encrypt/aes.h
#include "ble_gfps.h"
#include "_sha256.h"
#include "uECC.h"
#include "stdlib.h"
#include "types.h"
#include "uECC_vli.h"

const uint8_t *ptr_private_key=NULL;
const uint8_t *ptr_public_key =NULL;

uint32_t gfps_SHA256_hash(const void* in_data, int len, void* out_data) 
{
    SHA256_CTX ctx;
    uint32_t err_code;

    err_code = _sha256_init(&ctx);
    Gfps_CheckParm(GFPS_ERROR_EXEC_FAIL, err_code == GFPS_SUCCESS);

    err_code = _sha256_update(&ctx, in_data, len);

    Gfps_CheckParm(GFPS_ERROR_EXEC_FAIL, err_code == GFPS_SUCCESS);

    err_code = _sha256_final(&ctx, out_data, 0);
    Gfps_CheckParm(GFPS_ERROR_EXEC_FAIL, err_code ==GFPS_SUCCESS);

    return GFPS_SUCCESS;
}

int rand_generator(uint8_t *dest, unsigned size) {

    while (size--) {
        *dest++ = (uint8_t)rand();
    }
    return 1;
}

void gfps_crypto_init(void)
{
    ptr_private_key=NULL;
    ptr_public_key =NULL;

    uECC_set_rng(&rand_generator);
}

uint32_t gfps_crypto_get_secret_decrypt(const uint8_t* in_encryptdata ,
                                                const uint8_t *in_public_key,
                                                uint8_t * out_key,
                                                uint8_t *out_decryptdata){

    const struct uECC_Curve_t * curves = uECC_secp256r1();
    uint8_t secret_256AES_key[32] = {0};
    uint8_t hashed_256AES_key[32] = {0};
    if(ptr_private_key ==NULL)
    {
       return GFPS_ERROR_NULL;
    }
    if (!uECC_shared_secret(in_public_key, ptr_private_key, secret_256AES_key, curves)) {
        return GFPS_ERROR_EXEC_FAIL;
    }
   
    if (gfps_SHA256_hash(secret_256AES_key,32,hashed_256AES_key)!=GFPS_SUCCESS)
    {
        return GFPS_ERROR_EXEC_FAIL;
    }
    //get the out put cscret
    //get the out put AES128 decrypt key.
    memcpy(out_key, hashed_256AES_key, 16); 

    AES128_ECB_decrypt((uint8_t *)in_encryptdata, (const uint8_t *)hashed_256AES_key,out_decryptdata);
    
    return GFPS_SUCCESS;
};

uint32_t gfps_crypto_encrypt(const uint8_t *in_data,uint8_t len,const uint8_t *AESkey,uint8_t *out_encrypt)
{
    AES_set_key_varible(len);
    if(len == 16)
    {   
        AES128_ECB_encrypt((uint8_t *)in_data,AESkey,out_encrypt);
        return GFPS_SUCCESS;
    }else if(len == 32)
    {
        
        AES256_ECB_encrypt((uint8_t *)in_data,AESkey,out_encrypt);
        return GFPS_SUCCESS;
    }else
    {
        return GFPS_ERROR_INVALID_PARAM;
    }    
}
uint32_t gfps_crypto_decrypt(const uint8_t *in_data,uint8_t len,const uint8_t *AESkey,uint8_t *out_encrypt)
{
    AES_set_key_varible(len);
    if(len == 16)
    {   
        AES128_ECB_decrypt((uint8_t *)in_data,AESkey,out_encrypt);
        return GFPS_SUCCESS;
    }
    else if(len == 32)
    {
        AES256_ECB_decrypt((uint8_t *)in_data,AESkey,out_encrypt);
        return GFPS_SUCCESS;
    }
    else
    {
        return GFPS_ERROR_INVALID_PARAM;
    }    
}

uint32_t gfps_crypto_make_P256_key(uint8_t * out_public_key,uint8_t * out_private_key)
{
    //NIST P-256 is the same name of  secp256r1   
    if(ptr_private_key!=NULL &&ptr_public_key!=NULL)
    {
        memcpy(out_private_key, ptr_private_key, 32);
        memcpy(out_public_key, ptr_public_key, 64);
        
        return GFPS_SUCCESS;
    }
    return GFPS_ERROR_NULL;
}

uint32_t gfps_crypto_set_p256_key(const uint8_t* in_public_key,const uint8_t* in_private_key)
{
    ptr_private_key = in_private_key;
    ptr_public_key  = in_public_key;
    return GFPS_SUCCESS;
}

static void gfps_calculate_hmac(uint8_t* aesKey, uint8_t keyLen, uint8_t* nonce, uint8_t nonceLen,
    uint8_t* inputData, uint32_t inputDataLen, uint8_t* outputHmac, uint8_t outputLen)
{
    // Generate HMAC-SHA256 by
    // sha256(concat((K ^ opad), sha256(concat((K ^ ipad), concat(nonce, encrypted_name)))))

    // K is generated by concat(shared_secret, 48-byte ZEROs), the shared_secret is from step 4 in the above procedure.
    // opad is 64 bytes outer padding, consisting of repeated bytes valued 0x5C.
    // ipad is 64 bytes inner padding, consisting of repeated bytes valued 0x36.

    uint32_t index;

    // prepare K
    uint8_t len = 64;
    uint8_t shaLen =32;
    uint8_t K[len];
    memset(K, 0, len);

    if(aesKey && (keyLen != 0) && (keyLen < len))
    {
        memcpy(K, aesKey, keyLen);
    }

    // prepare concat((K ^ opad)
    uint8_t firstChunkToDoSha256[len];
    for (index = 0; index < len; index++)
    {
        firstChunkToDoSha256[index] = K[index]^0x5C;
    }

    // prepare concat((K ^ ipad), concat(nonce, encrypted_name))
    uint8_t dataToDo1stSha256[len+nonceLen+inputDataLen];
    for (index = 0; index < len; index++)
    {
        dataToDo1stSha256[index] = K[index]^0x36;
    }

    if(nonce && (nonceLen != 0))
    {
        memcpy(&dataToDo1stSha256[len], nonce, nonceLen);
    }

    if(inputData && (inputDataLen != 0))
    {
        memcpy(&dataToDo1stSha256[len+nonceLen], inputData, inputDataLen);
    }

    //  sha256(concat((K ^ ipad), concat(nonce, encrypted_name))))
    uint8_t firstSha256[shaLen];
    gfps_SHA256_hash(dataToDo1stSha256, len+nonceLen+inputDataLen, firstSha256);

    // prepare concat((K ^ opad), sha256(concat((K ^ ipad), concat(nonce, encrypted_name))))
    uint8_t dataToDo2ndSha256[len+shaLen];
    memcpy(dataToDo2ndSha256, firstChunkToDoSha256, len);
    memcpy(&dataToDo2ndSha256[len], firstSha256, shaLen);

    // calculate the final sha256
    uint8_t finalSha256[shaLen];
    gfps_SHA256_hash(dataToDo2ndSha256, len+shaLen, finalSha256);

    // 4. Take the first 8 bytes from the HMAC-SHA256 as the prefix of the
    memcpy(outputHmac, finalSha256, outputLen);
}

// app_gfps_env.keybase_pair_key
void gfps_encrypt_name(uint8_t* aesKey, uint8_t* inputRawName, uint32_t inputLen, 
    uint8_t* outputEncryptedName, uint8_t* hmacFirst8Bytes, uint8_t* nonce)
{
    // 1. generate 8 bytes random number for nonce
    rand_generator(nonce, 8);

    // 2. Encrypt the name using AES-CTR, where each 16-byte block is generated using
    // encryptedBlock[i] = clearBlock[i] ^ AES(key, concat((uint8) i, 0x00000000000000, nonce))
    uint8_t encryptedName[inputLen];
    uint32_t blockCnt = (inputLen + 15)/16;
    for (uint32_t block = 0;block < blockCnt;block++)
    {
        uint8_t initialVector[16];        
        initialVector[0] = block;        
        memset(&initialVector[1], 0, 7);
        memcpy(&initialVector[8], nonce, 8);

        uint8_t bytes;
        if ((blockCnt-1) == block)
        {
            bytes = inputLen-16*block;
        }
        else
        {
            bytes = 16;
        }
        TRACE(2,"block %d bytes %d", block, bytes);
        DUMP8("%02x ", &inputRawName[16*block], bytes);
        DUMP8("%02x ", aesKey, 16);
        DUMP8("%02x ", initialVector, 16);
        AES128_CTR_encrypt_buffer(&inputRawName[16*block], bytes, 
            aesKey, initialVector, &encryptedName[16*block]);
        DUMP8("%02x ", &encryptedName[16*block], bytes);
            
    }

    memcpy(outputEncryptedName, encryptedName, inputLen);

    gfps_calculate_hmac(aesKey, 16, nonce, 8, encryptedName, inputLen, hmacFirst8Bytes, 8);
    
}

// app_gfps_env.aesKeyFromECDH or app_gfps_env.keybase_pair_key
bool gfps_decrypt_name(uint8_t* aesKey, uint8_t* hmacFirst8Bytes, 
    uint8_t* nonce, uint8_t* encryptedName, uint8_t* rawName, uint32_t nameLen)
{
    // 1. Verify the integrity of the data by checking the first 8 bytes of HMAC-SHA256.
    uint8_t calculatedHmacFirst8Bytes[8];
    gfps_calculate_hmac(aesKey, 16, nonce, 8, encryptedName, nameLen, calculatedHmacFirst8Bytes, 8);

    if (memcmp(calculatedHmacFirst8Bytes, hmacFirst8Bytes, sizeof(calculatedHmacFirst8Bytes)))
    {
        return false;
    }

    // 2. Decrypt the encrypted name using AES-CTR, where each block is generated using
    // clearBlock[i] = encryptedBlock[i] ^ AES(key, concat((uint8) i, 0x00000000000000, nonce))
    // where

    // encryptedBlock[i] is a 16-byte block start from encrypted_name[i * 16]. The last block can be less than 16 bytes.
    // AES key:
    // in naming flow 1, it is from ECDH, and it will not be used again for this pairing. Any requests which come in encrypted with this key without restarting the procedure above should be rejected.
    // in naming flow 2, it is the account key.

    uint32_t blockCnt = (nameLen + 15)/16;
    for (uint32_t block = 0;block < blockCnt;block++)
    {
        uint8_t initialVector[16];        
        initialVector[0] = block;        
        memset(&initialVector[1], 0, 7);
        memcpy(&initialVector[8], nonce, 8);

        uint8_t bytes;
        if ((blockCnt-1) == block)
        {
            bytes = nameLen-16*block;
        }
        else
        {
            bytes = 16;
        }

        AES128_CTR_encrypt_buffer(&encryptedName[16*block], bytes, 
            aesKey, initialVector, &rawName[16*block]);
    }

    return true;
}

void gfps_encrypt_messasge(uint8_t* accKey, uint8_t* nonce,
    uint8_t* inputData, uint32_t inputDataLen, uint8_t* outputHmacFirst8Bytes)
{
    gfps_calculate_hmac(accKey, 16, nonce, 16, inputData, inputDataLen, outputHmacFirst8Bytes, 8);
}

void gfps_hmac_withoutnonce(uint8_t* key, uint8_t keyLen, uint8_t* msg, uint8_t msgLen,
    uint8_t* output, uint8_t outputLen)
{
    // Generate HMAC-SHA256(key, msg) = SHA256((key ^ opod) || SHA256((key ^ ipad) || msg))
    gfps_calculate_hmac(key, keyLen, NULL, 0, msg, msgLen, output, outputLen);
}

//hkdf test
/*
Basic test case with SHA-256
Hash = SHA-256
IKM = 0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b (22 octets)
salt = 0x000102030405060708090a0b0c (13 octets)
info = 0xf0f1f2f3f4f5f6f7f8f9 (10 octets)
L = 42
PRK = 0x077709362c2e32df0ddc3f0dc47bba63
90b6c73bb50f9c3122ec844ad7c2b3e5 (32 octets)
OKM = 0x3cb25f25faacd57a90434f64d0362f2a
2d2d0a90cf1a5a4c5db02d56ecc4c5bf
34007208d5b887185865 (42 octets)
uint8_t s[13] = {0x0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c};
uint8_t ikm[22] = {0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b};
uint8_t info[10] = {0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9};
uint8_t okm[42]= {0};
gfps_hdkf(s, 13, ikm, 22, info, 10, okm, 42);
TRACE(0, "okm is:");
DUMP8("%2x ", okm, 42);
*/

void gfps_hdkf(uint8_t *salt, uint8_t saltLen, uint8_t* ikm, uint8_t ikmLen,
    uint8_t*inputData, uint32_t inputDataLen, uint8_t* output, uint8_t outputLen)
{
    // HKDF(accountkey, NULL, UTF8("SASS-RRD-KEY"), 16);
    //step1 :hdkf extract HMAC-SHA256(salt, IKM) -> PRK, IKM is the input or message.
    uint8_t PRK[32] = {0};
    uint8_t hdkf[32] = {0};
    uint8_t T[32 + inputDataLen + 1];
    uint8_t N, hLen = 0, tLen = 0;
    if(output == NULL || outputLen == 0)
    {
        return;
    }
    else if(outputLen%32) {
        N = outputLen/32 + 1;
    } else {
        N = outputLen/32;
    }

    gfps_hmac_withoutnonce(salt, saltLen, ikm, ikmLen, PRK, 32);

    //step 2: hdkf expand
    // T= T(0) || T(1) || T(2) ..T(N), output is the first outputLen octets of T
    // T(0) = empty string
    // T(1) = hmac_hash(PRK, T(0) || info || 0x01)
    // T(2) = hmac_hash(PRK, T(1) || info || 0x02)
    memset(T, 0, 32 + inputDataLen + 1);

    for(uint8_t index = 0 ; index < N; index++)
    {
        if(inputData && (inputDataLen != 0))
        {
            memcpy(T+tLen, (uint8_t *)inputData, inputDataLen);
        }
        tLen += inputDataLen;
        T[tLen] = index + 1;
        tLen += 1;
        gfps_hmac_withoutnonce(PRK, 32, T, tLen, hdkf, 32);
        if((outputLen - hLen) < 32) {
            memcpy(output+hLen, hdkf, outputLen - hLen);
            break;
        } else {
            memcpy(output+hLen, hdkf, 32);
            hLen += 32;
        }
        memcpy(T, hdkf, 32);
        tLen = 32;
    }
}

void gfps_beacon_encrpt_data(uint8_t* accKey,
    uint8_t* inputData, uint32_t inputDataLen, uint8_t* outputHmacFirst8Bytes)
{
    gfps_hmac_withoutnonce(accKey, 16, inputData, inputDataLen, outputHmacFirst8Bytes, 8);
}
#endif /* GFPS_ENABLED */